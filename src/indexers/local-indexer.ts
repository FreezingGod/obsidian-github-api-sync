import { normalizePath, TFile, type App } from "obsidian";
import { createHash } from "crypto";
import picomatch from "picomatch";
import type { LocalIndex, SyncBaseline } from "../types/sync-types";
import type { LocalIndexer } from "../types/interfaces";

export class LocalVaultIndexer implements LocalIndexer {
  private app: App;
  private previousBaseline: SyncBaseline | null = null;
  private maxFileSizeBytes: number = 50 * 1024 * 1024; // 50MB default

  constructor(app: App) {
    this.app = app;
  }

  setPreviousBaseline(baseline: SyncBaseline | null): void {
    this.previousBaseline = baseline;
  }

  setMaxFileSizeMB(maxSizeMB: number): void {
    this.maxFileSizeBytes = maxSizeMB * 1024 * 1024;
  }

  async scan(rootPath: string, ignorePatterns: string[]): Promise<LocalIndex> {
    const normalizedRoot = rootPath.trim() === "" ? "" : normalizePath(rootPath);
    const files = this.app.vault.getFiles();
    const index: LocalIndex = {};
    const skippedFiles: string[] = [];

    for (const file of files) {
      if (!this.isUnderRoot(file, normalizedRoot)) {
        continue;
      }

      if (this.isIgnored(file.path, ignorePatterns)) {
        continue;
      }

      // Check file size
      if (file.stat.size > this.maxFileSizeBytes) {
        skippedFiles.push(file.path);
        console.warn(
          `Skipping large file: ${file.path} (${(file.stat.size / 1024 / 1024).toFixed(2)}MB exceeds ${(this.maxFileSizeBytes / 1024 / 1024).toFixed(0)}MB limit)`
        );
        continue;
      }

      const hash = await this.computeHashOptimized(file);
      index[file.path] = {
        path: file.path,
        hash,
        mtime: file.stat.mtime,
        size: file.stat.size,
      };
    }

    if (skippedFiles.length > 0) {
      console.warn(`Skipped ${skippedFiles.length} large file(s):`, skippedFiles);
    }

    return index;
  }

  private async computeHashOptimized(file: TFile): Promise<string> {
    // Check if we can reuse cached hash from baseline
    const baseEntry = this.previousBaseline?.entries[file.path];
    if (baseEntry?.hash && baseEntry.mtime === file.stat.mtime && baseEntry.size === file.stat.size) {
      // File unchanged based on mtime and size, reuse cached hash
      return baseEntry.hash;
    }

    // File is new or changed, compute hash
    return this.computeHash(file);
  }

  async computeHash(file: TFile): Promise<string> {
    const data = await this.app.vault.readBinary(file);
    const buffer = Buffer.from(data);
    return createHash("sha256").update(buffer).digest("hex");
  }

  private isUnderRoot(file: TFile, rootPath: string): boolean {
    if (rootPath === "") {
      return true;
    }

    const normalized = normalizePath(file.path);
    if (normalized === rootPath) {
      return true;
    }

    return normalized.startsWith(`${rootPath}/`);
  }

  private isIgnored(path: string, ignorePatterns: string[]): boolean {
    if (ignorePatterns.length === 0) {
      return false;
    }

    const normalized = normalizePath(path);

    // Use picomatch for robust glob pattern matching
    for (const pattern of ignorePatterns) {
      const trimmed = pattern.trim();
      if (!trimmed) {
        continue;
      }

      // Handle directory patterns (ending with /)
      if (trimmed.endsWith("/")) {
        const dirPattern = normalizePath(trimmed);
        if (normalized.startsWith(dirPattern) || normalized === dirPattern.slice(0, -1)) {
          return true;
        }
      } else {
        // Use picomatch for advanced glob matching
        const isMatch = picomatch(normalizePath(trimmed), {
          dot: true, // Match dotfiles
          noglobstar: false, // Enable ** for recursive matching
        });

        if (isMatch(normalized)) {
          return true;
        }
      }
    }

    return false;
  }
}
